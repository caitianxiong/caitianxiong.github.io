<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Have A Nice Day</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://caitianxiong.github.io/"/>
  <updated>2017-02-28T06:55:30.000Z</updated>
  <id>https://caitianxiong.github.io/</id>
  
  <author>
    <name>Leon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>集成Ceph到DevStack</title>
    <link href="https://caitianxiong.github.io/2017/02/28/integrate-ceph-into-devstack/"/>
    <id>https://caitianxiong.github.io/2017/02/28/integrate-ceph-into-devstack/</id>
    <published>2017-02-28T06:35:53.000Z</published>
    <updated>2017-02-28T06:55:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>已经搭建好的 <code>Mon*1 + OSD*3</code> 的Ceph-10.2.5测试集群</li>
<li>All-In-One的Newton版DevStack环境，参考<a href="https://docs.openstack.org/developer/devstack/" target="_blank" rel="external">DevStack部署文档</a><a id="more"></a>
</li>
</ul>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="创建pool"><a href="#创建pool" class="headerlink" title="创建pool"></a>创建pool</h2><ul>
<li>Ceph集群创建几个pool：images/volumes/backups/vms<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ceph osd pool create volumes 128 (pg大小根据自己的Ceph集群规模调整）</div><div class="line">ceph osd pool create images 128</div><div class="line">ceph osd pool create backups 128</div><div class="line">ceph osd pool create vms 128</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="配置OpenStack-Ceph客户端"><a href="#配置OpenStack-Ceph客户端" class="headerlink" title="配置OpenStack Ceph客户端"></a>配置OpenStack Ceph客户端</h2><ul>
<li>将ceph.conf配置文件复制到openstack节点，包括：运行 glance-api, cinder-volume, nova-compute 和 cinder-backup 的节点，都作为Ceph client。</li>
</ul>
<h3 id="安装Ceph客户端"><a href="#安装Ceph客户端" class="headerlink" title="安装Ceph客户端"></a>安装Ceph客户端</h3><ul>
<li>在运行glance-api的节点，安装<code>python-rbd</code>库，<code>yum install python-rbd -y</code></li>
<li>在运行nova-compute, cinder-backup 和 cinder-volume 节点，安装python-rbd库和ceph命令行工具：<code>yum install python-rbd ceph-common -y</code></li>
</ul>
<h3 id="配置Ceph客户端认证"><a href="#配置Ceph客户端认证" class="headerlink" title="配置Ceph客户端认证"></a>配置Ceph客户端认证</h3><ul>
<li><p>为Nova/Cinder/Glance创建新用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ceph auth get-or-create client.glance mon &apos;allow r&apos; osd &apos;allow class-read object_prefix rbd_children, allow rwx pool=images&apos;</div><div class="line">ceph auth get-or-create client.cinder-backup mon &apos;allow r&apos; osd &apos;allow class-read object_prefix rbd_children, allow rwx pool=backups&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>Mitaka及之后的版本，引入了RBD快照的支持（做Nova实例的快照），因此需要配置<code>client.cinder</code> key对images pool的写权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph auth get-or-create client.cinder mon &apos;allow r&apos; osd &apos;allow class-read object_prefix rbd_children, allow rwx pool=volumes, allow rwx pool=vms, allow rwx pool=images&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>将<code>client.cinder, client.glance, 和 client.cinder-backup</code>的 keyring 添加到相应的节点，并改变其属主：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ceph auth get-or-create client.glance | ssh &#123;your-glance-api-server&#125; sudo tee /etc/ceph/ceph.client.glance.keyring</div><div class="line">ssh &#123;your-glance-api-server&#125; sudo chown glance:glance /etc/ceph/ceph.client.glance.keyring</div><div class="line">ceph auth get-or-create client.cinder | ssh &#123;your-volume-server&#125; sudo tee /etc/ceph/ceph.client.cinder.keyring</div><div class="line">ssh &#123;your-cinder-volume-server&#125; sudo chown cinder:cinder /etc/ceph/ceph.client.cinder.keyring</div><div class="line">ceph auth get-or-create client.cinder-backup | ssh &#123;your-cinder-backup-server&#125; sudo tee /etc/ceph/ceph.client.cinder-backup.keyring</div><div class="line">ssh &#123;your-cinder-backup-server&#125; sudo chown cinder:cinder /etc/ceph/ceph.client.cinder-backup.keyring</div></pre></td></tr></table></figure>
</li>
<li><p>运行nova-compute进程的节点也需要client.cinder的keyring文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph auth get-or-create client.cinder | ssh &#123;your-nova-compute-server&#125; sudo tee /etc/ceph/ceph.client.cinder.keyring</div></pre></td></tr></table></figure>
</li>
<li><p><strong>计算节点</strong>上，还需要把client.cinder的keyring文件保存到libvirt中。libvirt进程从Cinder挂载一个块设备时，需要访问jCeph集群。</p>
<ul>
<li>创建一个临时文件 <code>ceph auth get-key client.cinder | ssh {your-compute-node} tee client.cinder.key</code></li>
<li><p>将秘钥加到libvirt中，并删除临时文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">uuidgen</div><div class="line">457eb676-33da-42ec-9a8c-9293d545c337</div><div class="line"></div><div class="line">cat &gt; secret.xml &lt;&lt;EOF</div><div class="line">&lt;secret ephemeral=&apos;no&apos; private=&apos;no&apos;&gt;</div><div class="line">  &lt;uuid&gt;457eb676-33da-42ec-9a8c-9293d545c337&lt;/uuid&gt;</div><div class="line">  &lt;usage type=&apos;ceph&apos;&gt;</div><div class="line">    &lt;name&gt;client.cinder secret&lt;/name&gt;</div><div class="line">  &lt;/usage&gt;</div><div class="line">&lt;/secret&gt;</div><div class="line">EOF</div><div class="line">sudo virsh secret-define --file secret.xml</div><div class="line">Secret 457eb676-33da-42ec-9a8c-9293d545c337 created</div><div class="line">sudo virsh secret-set-value --secret 457eb676-33da-42ec-9a8c-9293d545c337 --base64 $(cat client.cinder.key) &amp;&amp; rm client.cinder.key secret.xml</div></pre></td></tr></table></figure>
</li>
<li><p>查看libvirt保存的秘钥的uuid的方法：<code>virsh secret-list</code></p>
</li>
<li>查看secret-value: <code>virsh secret-get-value UUID</code></li>
</ul>
</li>
</ul>
<h3 id="配置OpenStack来使用Ceph【改配置文件之前最好备份】"><a href="#配置OpenStack来使用Ceph【改配置文件之前最好备份】" class="headerlink" title="配置OpenStack来使用Ceph【改配置文件之前最好备份】"></a>配置OpenStack来使用Ceph【改配置文件之前最好备份】</h3><h4 id="配置Glance"><a href="#配置Glance" class="headerlink" title="配置Glance"></a>配置Glance</h4><ul>
<li>编辑<code>/etc/glance/glance-api.conf</code> :<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[DEFAULT]</div><div class="line">...</div><div class="line">show_image_direct_url = True # 启用images的copy-on-write克隆</div><div class="line">...</div><div class="line">[glance_store]</div><div class="line">stores = rbd</div><div class="line">default_store = rbd</div><div class="line">rbd_store_pool = images</div><div class="line">rbd_store_user = glance</div><div class="line">rbd_store_ceph_conf = /etc/ceph/ceph.conf</div><div class="line">rbd_store_chunk_size = 8</div><div class="line">...</div><div class="line">[paste_deploy]</div><div class="line">flavor = keystone # 不缓存镜像</div><div class="line">...</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="配置Cinder"><a href="#配置Cinder" class="headerlink" title="配置Cinder"></a>配置Cinder</h4><ul>
<li><p>编辑<code>/etc/cinder/cinder.conf</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[DEFAULT]</div><div class="line">...</div><div class="line">enabled_backends = ceph</div><div class="line">...</div><div class="line">[ceph]</div><div class="line">volume_driver = cinder.volume.drivers.rbd.RBDDriver</div><div class="line">volume_backend_name = ceph</div><div class="line">rbd_pool = volumes</div><div class="line">rbd_ceph_conf = /etc/ceph/ceph.conf</div><div class="line">rbd_flatten_volume_from_snapshot = false</div><div class="line">rbd_max_clone_depth = 5</div><div class="line">rbd_store_chunk_size = 4</div><div class="line">rados_connect_timeout = -1</div><div class="line">glance_api_version = 2</div></pre></td></tr></table></figure>
</li>
<li><p>如果开启了cephx认证，还需要libvirt中保存的秘钥的user和uuid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ceph]</div><div class="line">...</div><div class="line">rbd_user = cinder</div><div class="line">rbd_secret_uuid = $UUID # 使用之前存在libvirt中的UUID</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="配置Cinder-Backup"><a href="#配置Cinder-Backup" class="headerlink" title="配置Cinder Backup"></a>配置Cinder Backup</h4><ul>
<li>修改<code>/etc/cinder/cinder.conf</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">backup_driver = cinder.backup.drivers.ceph</div><div class="line">backup_ceph_conf = /etc/ceph/ceph.conf</div><div class="line">backup_ceph_user = cinder-backup</div><div class="line">backup_ceph_chunk_size = 134217728</div><div class="line">backup_ceph_pool = backups</div><div class="line">backup_ceph_stripe_unit = 0</div><div class="line">backup_ceph_stripe_count = 0</div><div class="line">restore_discard_excess_bytes = true</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="配置Nova"><a href="#配置Nova" class="headerlink" title="配置Nova"></a>配置Nova</h4><ul>
<li>修改<code>/etc/nova/nova.conf</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[libvirt]</div><div class="line">virt_type = qemu</div><div class="line">images_type = rbd</div><div class="line">images_rbd_pool = vms</div><div class="line">images_rbd_ceph_conf = /etc/ceph/ceph.conf</div><div class="line">rbd_user = cinder</div><div class="line">rbd_secret_uuid = $UUID</div><div class="line">disk_cachemodes=&quot;network=writeback&quot;</div><div class="line">live_migration_flag=&quot;VIR_MIGRATE_UNDEFINE_SOURCE,VIR_MIGRATE_PEER2PEER,VIR_MIGRATE_LIVE,VIR_MIGRATE_PERSIST_DEST,VIR_MIGRATE_TUNNELLED&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="重启相关服务"><a href="#重启相关服务" class="headerlink" title="重启相关服务"></a>重启相关服务</h1><h2 id="需要重启的服务"><a href="#需要重启的服务" class="headerlink" title="需要重启的服务"></a>需要重启的服务</h2><ul>
<li>glance-api (g-api)</li>
<li>glance-registry (g-reg)</li>
<li>nova-compute (n-cpu)</li>
<li>cinder-volume (<code>c-vol*</code>)</li>
<li>cinder-api (c-api)</li>
<li>cinder-schduler (c-sch)</li>
</ul>
<h2 id="重启方法"><a href="#重启方法" class="headerlink" title="重启方法"></a>重启方法</h2><p>由于devstack启动服务的方式比较特殊，安装的所有服务都运行在screen中，要重启服务，需要找到对应的screen，在其中进行重启操作。参考<a href="http://1.chaoxu.sinaapp.com/archives/3311" target="_blank" rel="external">这篇博客</a>。</p>
<ul>
<li><p>输入<code>screen -list</code>，查看当前用户开启的所有screen</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[stack@devstack devstack]$ screen -list</div><div class="line">There is a screen on:</div><div class="line">    2756.stack    (Detached)</div><div class="line">1 Socket in /var/run/screen/S-stack.</div></pre></td></tr></table></figure>
</li>
<li><p>附加到screen：<code>screen -r $screen_id # 上面的2756</code></p>
</li>
<li>依次执行<code>control + a</code> 和 <code>control + d</code> 来退出当前的screen</li>
<li>进入某个screen的方法，<code>control + a + &#39;</code>，然后输入屏幕下方的数字，敲回车，切换到相应的screen。</li>
<li>停止服务<code>control + c</code>，重新启动<code>↑ + enter</code></li>
</ul>
<h1 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h1><ul>
<li>用openstack命令创建镜像：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@devstack devstack]# openstack image create &quot;cirros-raw&quot; --file files/cirros-0.3.4-x86_64-disk.raw --disk-format qcow2 --container-format bare --public</div></pre></td></tr></table></figure>
</li>
</ul>
<p>成功后可以用<code>rbd ls images</code>查看到</p>
<ul>
<li>在控制台创建新卷，成功后可以用<code>rbd ls volumes</code> 查到到</li>
<li>在控制台用新上传的镜像启动云主机，成功后可以用<code>rbs ls vms</code>查看到。【此处不知为何没有生效，新建的云主机镜像文件保存到了volumes pool中】</li>
</ul>
<h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><h3 id="控制台创建卷时，卷类型没有CEPH可选，显示无类型"><a href="#控制台创建卷时，卷类型没有CEPH可选，显示无类型" class="headerlink" title="控制台创建卷时，卷类型没有CEPH可选，显示无类型"></a>控制台创建卷时，卷类型没有CEPH可选，显示无类型</h3><ul>
<li>需要在cinder节点上添加：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cinder type-list # 只能看到一个lvmdirver-1</div><div class="line">cinder type-create --is-public True ceph</div></pre></td></tr></table></figure>
</li>
</ul>
<p>此时再到控制台创建，就可以看到有CEPH类型可选了。</p>
<h3 id="无法创建VM，报错Block-Device-Mapping-is-Invalid"><a href="#无法创建VM，报错Block-Device-Mapping-is-Invalid" class="headerlink" title="无法创建VM，报错Block Device Mapping is Invalid"></a>无法创建VM，报错<code>Block Device Mapping is Invalid</code></h3><ul>
<li>问题在于用的启动镜像，还是用之前的file镜像，跟ceph配置冲突。使用新上传到glance中的镜像进行启动就可以了</li>
</ul>
<h3 id="创建云主机时报错：No-valid-host-available"><a href="#创建云主机时报错：No-valid-host-available" class="headerlink" title="创建云主机时报错：No valid host available"></a>创建云主机时报错：No valid host available</h3><ul>
<li>首先用<code>free</code>等命令确认物理机资源足够flavor使用</li>
<li>最后发现，问题出在nova.conf配置文件中的virt_type项，参考博客设置的qemu，改回kvm就好了</li>
<li>关于这个配置项，在OpenStack官方文档找到如下的解释：<blockquote>
<p>Describes the virtualization type (or so called domain type) libvirt should use.<br>The choice of this type must match the underlying virtualization strategy you have chosen for this host.</p>
</blockquote>
</li>
</ul>
<p>用来指定libvirt使用的虚拟化类型，必须和宿主机上选择的虚拟化策略一致。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>Ceph 官方文档 <a href="http://docs.ceph.com/docs/master/rbd/rbd-openstack/" target="_blank" rel="external">BLOCK DEVICES AND OPENSTACK</a>。文档中是按多节点部署的环境说明的，我部署的环境是All-In-One的单节点环境，所有服务的用户都是<code>stack.stack</code>，在相应的命令中替换掉即可。</li>
<li><a href="https://docs.openstack.org/developer/devstack/" target="_blank" rel="external">部署DevStack文档</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;已经搭建好的 &lt;code&gt;Mon*1 + OSD*3&lt;/code&gt; 的Ceph-10.2.5测试集群&lt;/li&gt;
&lt;li&gt;All-In-One的Newton版DevStack环境，参考&lt;a href=&quot;https://docs.openstack.org/developer/devstack/&quot;&gt;DevStack部署文档&lt;/a&gt;
    
    </summary>
    
    
      <category term="Ceph" scheme="https://caitianxiong.github.io/tags/Ceph/"/>
    
      <category term="OpenStack" scheme="https://caitianxiong.github.io/tags/OpenStack/"/>
    
      <category term="DevStack" scheme="https://caitianxiong.github.io/tags/DevStack/"/>
    
  </entry>
  
  <entry>
    <title>手动部署Ceph集群</title>
    <link href="https://caitianxiong.github.io/2017/02/25/deploy-ceph-cluster-manually/"/>
    <id>https://caitianxiong.github.io/2017/02/25/deploy-ceph-cluster-manually/</id>
    <published>2017-02-25T11:16:30.000Z</published>
    <updated>2017-02-28T07:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@node1 ~]# uname -r</div><div class="line">3.10.0-327.28.3.el7.x86_64</div><div class="line">[root@node1 ~]# cat /etc/redhat-release</div><div class="line">CentOS Linux release 7.3.1611 (Core)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="安装Ceph-10-2-5"><a href="#安装Ceph-10-2-5" class="headerlink" title="安装Ceph-10.2.5"></a>安装Ceph-10.2.5</h2><ul>
<li>添加KEYS <code>sudo rpm --import &#39;https://download.ceph.com/keys/release.asc&#39;</code></li>
<li><p>添加yum源<code>ceph.repo</code>，其中<code>jewel/el7</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">[ceph]</div><div class="line">name=Ceph packages for $basearch</div><div class="line">baseurl=https://download.ceph.com/rpm-&#123;ceph-release&#125;/&#123;distro&#125;/$basearch</div><div class="line">enabled=1</div><div class="line">priority=2</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=https://download.ceph.com/keys/release.asc</div><div class="line"></div><div class="line">[ceph-noarch]</div><div class="line">name=Ceph noarch packages</div><div class="line">baseurl=https://download.ceph.com/rpm-&#123;ceph-release&#125;/&#123;distro&#125;/noarch</div><div class="line">enabled=1</div><div class="line">priority=2</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=https://download.ceph.com/keys/release.asc</div><div class="line"></div><div class="line">[ceph-source]</div><div class="line">name=Ceph source packages</div><div class="line">baseurl=https://download.ceph.com/rpm-&#123;ceph-release&#125;/&#123;distro&#125;/SRPMS</div><div class="line">enabled=0</div><div class="line">priority=2</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=https://download.ceph.com/keys/release.asc</div></pre></td></tr></table></figure>
</li>
<li><p>安装依赖 <code>sudo yum install snappy leveldb gdisk python-argparse gperftools-libs -y</code>【其中的leveldb需要先安装epel的yum源，<code>yum install epel-release -y</code>】</p>
</li>
<li>安装ceph，<code>yum install ceph -y</code></li>
</ul>
<h2 id="安装块设备虚拟化"><a href="#安装块设备虚拟化" class="headerlink" title="安装块设备虚拟化"></a>安装块设备虚拟化</h2><ul>
<li>QEMU <code>yum update &amp;&amp; yum install qemu-kvm qemu-kvm-tools qemu-im</code></li>
<li>libvirt <code>yum install libvirt -y</code></li>
</ul>
<h2 id="部署ceph集群"><a href="#部署ceph集群" class="headerlink" title="部署ceph集群"></a>部署ceph集群</h2><p>参考官方文档<a href="http://docs.ceph.com/docs/master/install/manual-deployment/" target="_blank" rel="external">手动部署</a>，其中的启动命令过时了，应该用<code>systemctl</code>。具体步骤如下：</p>
<h3 id="MON"><a href="#MON" class="headerlink" title="MON"></a>MON</h3><ol>
<li>生成uuid</li>
<li><p>创建<code>ceph.conf</code>文件。<code>uuidgen</code> 生成uuid，写到<code>/etc/ceph/ceph.conf</code> 中作为<code>fsid</code>，同时写入mon信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fsid = a7f64266-0894-4f1e-a635-d0aeaca0e993</div><div class="line">mon initial members = node1</div><div class="line">mon host = 192.168.1.43</div></pre></td></tr></table></figure>
</li>
<li><p>创建keyring文件，并生成一个 monitor 秘钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-authtool --create-keyring /tmp/ceph.mon.keyring --gen-key -n mon. --cap mon &apos;allow *&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>生成administrator keyring，生成client.admin用户，并将用户添加到keyring</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo ceph-authtool --create-keyring /etc/ceph/ceph.client.admin.keyring --gen-key -n client.admin --set-uid=0 --cap mon &apos;allow *&apos; --cap osd &apos;allow *&apos; --cap mds &apos;allow&apos;</div></pre></td></tr></table></figure>
</li>
<li><p>添加<code>client.admin</code> key到<code>ceph.mon.keyring</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ceph-authtool /tmp/ceph.mon.keyring --import-keyring /etc/ceph/ceph.client.admin.keyring</div></pre></td></tr></table></figure>
</li>
<li><p>使用hostname、IP、FSID生成一个monitor map，保存到<code>/tmp/monmap</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">monmaptool --create --add &#123;hostname&#125; &#123;ip-address&#125; --fsid &#123;uuid&#125; /tmp/monmap</div></pre></td></tr></table></figure>
</li>
<li><p>在monitor主机上创建默认的数据目录，并修改属主为ceph</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir /var/lib/ceph/mon/&#123;cluster-name&#125;-&#123;hostname&#125;</div><div class="line">chown -R ceph.ceph /var/lib/ceph/mon</div></pre></td></tr></table></figure>
</li>
<li><p>将monitor map和keyring<strong>保存到（populate）</strong>monitor守护进程中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo -u ceph ceph-mon [--cluster &#123;cluster-name&#125;] --mkfs -i &#123;hostname&#125; --monmap /tmp/monmap --keyring /tmp/ceph.mon.keyring</div></pre></td></tr></table></figure>
</li>
<li><p>检查ceph.conf配置文件，根据需求，添加必要项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[global]</div><div class="line">fsid = &#123;cluster-id&#125;</div><div class="line">mon initial members = &#123;hostname&#125;[, &#123;hostname&#125;]</div><div class="line">mon host = &#123;ip-address&#125;[, &#123;ip-address&#125;]</div><div class="line">public network = &#123;network&#125;[, &#123;network&#125;]</div><div class="line">cluster network = &#123;network&#125;[, &#123;network&#125;]</div><div class="line">auth cluster required = cephx</div><div class="line">auth service required = cephx</div><div class="line">auth client required = cephx</div><div class="line">osd journal size = &#123;n&#125;</div><div class="line">osd pool default size = &#123;n&#125;  # Write an object n times.</div><div class="line">osd pool default min size = &#123;n&#125; # Allow writing n copy in a degraded state.</div><div class="line">osd pool default pg num = &#123;n&#125;</div><div class="line">osd pool default pgp num = &#123;n&#125;</div><div class="line">osd crush chooseleaf type = &#123;n&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>创建<code>done</code>文件，<code>touch /var/lib/ceph/mon/ceph-node1/done</code></p>
</li>
<li>启动monitor，<code>systemctl start ceph-mon@node1</code></li>
<li>查看集群状态，<code>ceph -s</code>，因为此时还没有OSD，所以集群是HEALTH_ERR状态，pg都是creating状态</li>
</ol>
<h3 id="OSD"><a href="#OSD" class="headerlink" title="OSD"></a>OSD</h3><ol>
<li>首先，将mon节点上的<code>/etc/ceph/ceph.conf</code>和<code>/etc/ceph/ceph.client.admin.keyring</code>文件复制到<code>/etc/ceph/</code>目录下</li>
<li>生成uuid，<code>uuidgen</code></li>
<li>创建OSD：<code>ceph osd create [{uuid}]</code>，这个命令会输出OSD的编号osd-num</li>
<li><p>创建OSD默认目录，并修改属主</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir /var/lib/ceph/osd/&#123;cluster-name&#125;-&#123;osd-num&#125;</div><div class="line">chown -R ceph.ceph /var/lib/ceph/osd</div></pre></td></tr></table></figure>
</li>
<li><p>格式化磁盘，<code>mkfs -t xfs /dev/{hdd}</code>；挂载到osd目录，<code>mount -o defaults /dev/{hdd} /var/lib/ceph/osd/{cluster-name}-{osd-number}</code></p>
</li>
<li>初始化OSD数据目录，执行这条命令前，目录必须是空的！<code>ceph-osd -i {osd-num} --mkfs --mkkey --osd-uuid {osd-uuid}</code></li>
<li>注册OSD认证key，<code>ceph auth add osd.{osd-num} osd &#39;allow *&#39; mon &#39;allow profile osd&#39; -i /var/lib/ceph/osd/{cluster-name}-{osd-num}/keyring</code></li>
<li>把Ceph节点添加到CRUSH map，<code>ceph [--cluster {cluster-name}] osd crush add-bucket {hostname} host</code></li>
<li>把Ceph节点移到<code>default</code>根下，<code>ceph osd crush move {hostname} root=default</code></li>
<li><p>把OSD添加到CRUSH map来让它接收数据。也可以反编译CRUSH map，把host加成一个bucket，把OSD加到host下的device list中，分配一个weight，然后重现编译导入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ceph [--cluster &#123;cluster-name&#125;] osd crush add &#123;id-or-name&#125; &#123;weight&#125; [&#123;bucket-type&#125;=&#123;bucket-name&#125; ...]</div><div class="line"># 例如：ceph osd crush add osd.0 1.0 host=node1</div></pre></td></tr></table></figure>
</li>
<li><p>启动OSD，<code>systemctl start ceph-osd@0</code></p>
</li>
<li>查看集群状态，<code>ceph -s</code>。待OSD数等于<code>pool size</code>时，所有pg会逐渐创建成功，pg状态变为<code>active+clean</code>，集群状态变为<code>HEALTH_OK</code></li>
</ol>
<h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="MON-1"><a href="#MON-1" class="headerlink" title="MON"></a>MON</h3><ul>
<li>记得将mon的data目录 <code>/var/lib/ceph/mon</code> 属主改成 <code>ceph.ceph</code></li>
<li>无法启动mon。【解决】官方文档的命令过时了，用 <code>systemctl start ceph-mon@node2</code> 这样启动，如果启动有问题，<blockquote>
<p>可以通过 <code>systemctl status ceph-mon@ceph-k-node1.service</code> 和 <code>journalctl -b _PID=‘pid’</code> 定位出错原因</p>
</blockquote>
</li>
</ul>
<h3 id="OSD-1"><a href="#OSD-1" class="headerlink" title="OSD"></a>OSD</h3><ul>
<li>执行<code>ceph osd create [uuid id]</code> 之前，需要把MON节点上的集群配置文件和admin.keyring文件复制过来。<code>/etc/ceph/[ceph.conf|ceph.client.admin.keyring]</code></li>
<li>需要将 <code>/var/lib/ceph/</code> 目录属主改成<code>ceph.ceph</code></li>
</ul>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://docs.ceph.com/docs/master/install/manual-deployment/" target="_blank" rel="external">Ceph官方文档-手动部署</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[root@node1 ~]# uname -r&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3.10.0-327.28.3.el7.x86_64&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[root@node1 ~]# cat /etc/redhat-release&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;CentOS Linux release 7.3.1611 (Core)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Ceph" scheme="https://caitianxiong.github.io/tags/Ceph/"/>
    
  </entry>
  
  <entry>
    <title>蔡旺作品展示</title>
    <link href="https://caitianxiong.github.io/2017/02/07/caiwang-works/"/>
    <id>https://caitianxiong.github.io/2017/02/07/caiwang-works/</id>
    <published>2017-02-07T10:44:58.000Z</published>
    <updated>2017-02-13T11:24:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇用于展示蔡旺的设计作品和摄影作品。(可点击图片放大查看)<br><a id="more"></a></p>
<hr>
<h1 id="PS-作品"><a href="#PS-作品" class="headerlink" title="PS 作品"></a><center>PS 作品</center></h1><hr>
<h4 id="海报设计"><a href="#海报设计" class="headerlink" title="海报设计"></a>海报设计</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/caiwang03.jpeg" alt="01 海报设计"></p>
<h4 id="产品Banner图"><a href="#产品Banner图" class="headerlink" title="产品Banner图"></a>产品Banner图</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/caiwang02.jpeg" alt="02 产品Banner图"></p>
<h4 id="网页切图"><a href="#网页切图" class="headerlink" title="网页切图"></a>网页切图</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/caiwang01.jpeg" alt="03 网页切图"></p>
<hr>
<h1 id="摄影作品"><a href="#摄影作品" class="headerlink" title="摄影作品"></a><center>摄影作品</center></h1><hr>
<h4 id="农场"><a href="#农场" class="headerlink" title="农场"></a>农场</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/%E5%86%9C%E5%9C%BA.jpg" alt="01 农场"></p>
<h4 id="泛舟江上"><a href="#泛舟江上" class="headerlink" title="泛舟江上"></a>泛舟江上</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/%E6%B3%9B%E8%88%9F%E6%B1%9F%E4%B8%8A.jpg" alt="02 泛舟江上"></p>
<h4 id="人物"><a href="#人物" class="headerlink" title="人物"></a>人物</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/%E4%BA%BA%E7%89%A9.jpg" alt="03 人物"></p>
<h4 id="暴风雨前"><a href="#暴风雨前" class="headerlink" title="暴风雨前"></a>暴风雨前</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/%E6%9A%B4%E9%A3%8E%E9%9B%A8%E5%89%8D.jpg" alt="04 暴风雨前"></p>
<h4 id="摇滚歌手"><a href="#摇滚歌手" class="headerlink" title="摇滚歌手"></a>摇滚歌手</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/%E6%91%87%E6%BB%9A%E6%AD%8C%E6%89%8B.jpg" alt="05 摇滚歌手"></p>
<h4 id="风景"><a href="#风景" class="headerlink" title="风景"></a>风景</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/%E9%A3%8E%E6%99%AF.jpg" alt="06 风景"></p>
<h4 id="风景2"><a href="#风景2" class="headerlink" title="风景2"></a>风景2</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/%E9%A3%8E%E6%99%AF2.jpg" alt="07 风景2"></p>
<h4 id="童年记忆"><a href="#童年记忆" class="headerlink" title="童年记忆"></a>童年记忆</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/%E7%AB%A5%E5%B9%B4%E8%AE%B0%E5%BF%86.jpg" alt="08 童年记忆"></p>
<h4 id="麻雀"><a href="#麻雀" class="headerlink" title="麻雀"></a>麻雀</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/%E9%BA%BB%E9%9B%80.jpg" alt="09 麻雀"></p>
<h4 id="桃花"><a href="#桃花" class="headerlink" title="桃花"></a>桃花</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/%E9%87%8E%E8%8A%B1.jpg" alt="10 桃花"></p>
<h4 id="树林"><a href="#树林" class="headerlink" title="树林"></a>树林</h4><p><img src="http://ock7ps6a9.bkt.clouddn.com/%E6%A0%91%E6%9E%97.jpg" alt="11 树林"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇用于展示蔡旺的设计作品和摄影作品。(可点击图片放大查看)&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web应用设置缓存总结</title>
    <link href="https://caitianxiong.github.io/2016/11/06/summary-of-web-cache/"/>
    <id>https://caitianxiong.github.io/2016/11/06/summary-of-web-cache/</id>
    <published>2016-11-06T11:17:54.000Z</published>
    <updated>2016-11-06T11:27:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ock7ps6a9.bkt.clouddn.com/image/blog/web_cache.png" alt="web_cache"></p>
<p>给Web应用设置缓存好处多多，可以提高访问速度，改善用户体验，减轻服务器压力等。本篇主要整理一下前段时间设置服务器端和浏览器端缓存的方法，以及几种做法的优点与弊端。虽然只是来自Django的经验，但我相信对于其他编程语言和框架，原理上应该是一样的。<br><a id="more"></a><br>首先，我们从一个HTTP请求的生命周期来看看，可以在哪些地方设置缓存。一个HTTP请求从浏览器发出，经过网络传输到硬件层面的服务器上，这台服务器上通常会配置有服务器软件（比如Nginx或者Apache），还可能配置有缓冲软件（比如Redis或者Memcached），然后才是正真干活处理请求的代码层面的server。</p>
<p>从多级缓存的角度看，一般是越近的存储，访问速度越快。我们web应用发送的HTTP请求，如果能在client本地就获取到请求的HTML文档（JS/CSS/图片文件都由解析HTML得到请求路径，为方便起见，我们这里只讨论HTML），那必然再快不过。于是有了第一类缓存方式：浏览器本地缓存。</p>
<h3 id="浏览器端判断是否使用缓存的方式分两类"><a href="#浏览器端判断是否使用缓存的方式分两类" class="headerlink" title="浏览器端判断是否使用缓存的方式分两类"></a>浏览器端判断是否使用缓存的方式分两类</h3><h4 id="1-需要跟服务器通信的：（validator）"><a href="#1-需要跟服务器通信的：（validator）" class="headerlink" title="1. 需要跟服务器通信的：（validator）"></a>1. 需要跟服务器通信的：（validator）</h4><ul>
<li>response头带<code>Last-Modified</code>属性，再次request时带上<code>If-Modified-Since</code>头部，由服务器来判断是否可以使用缓存；</li>
<li>response头带<code>ETag</code>属性，再次request时带<code>If-None-Match</code>，同样由服务器决定，若可以用cache，返回304。</li>
</ul>
<h4 id="2-不用跟服务器通信的：（freshness）"><a href="#2-不用跟服务器通信的：（freshness）" class="headerlink" title="2. 不用跟服务器通信的：（freshness）"></a>2. 不用跟服务器通信的：（freshness）</h4><ul>
<li>response头带<code>Expires</code>属性，再次request时浏览器将系统时间与<code>Expires</code>值比较，若没过期则直接使用缓存；</li>
<li>response头带<code>Cache-Control</code>属性，值为<code>max-age=XXXX</code>的形式，在过期时间内，request直接使用本地缓存。</li>
</ul>
<p>那么怎么让浏览器知道那些HTML要缓存哪些不要呢？这就要看server给返回的HTTP响应头部的参数了，现在的主流做法是设置<code>Cache-Control</code>，比如<code>Cache-Control: max-age=3600</code>，<code>max-age</code>的单位是秒，这样设置表示将这个资源在浏览器本地保留3600秒，除非用户手动删除，否则在这一小时内，浏览器再有对这个资源的请求时，就会直接从本地的缓存里取。是不是想想都有快感～</p>
<h3 id="浏览器端缓存设置方式"><a href="#浏览器端缓存设置方式" class="headerlink" title="浏览器端缓存设置方式"></a>浏览器端缓存设置方式</h3><h4 id="1-在Apache-Nginx中设置响应头"><a href="#1-在Apache-Nginx中设置响应头" class="headerlink" title="1. 在Apache/Nginx中设置响应头"></a>1. 在Apache/Nginx中设置响应头</h4><p>比如在Apache的配置文件中添加<code>Header set Cache-Control &quot;max-age=3600&quot;</code>。这种方式时全局的，任何响应都会加上配置的头部参数，粒度最大。这样设置的缓存会保留在用户的浏览器上。</p>
<h4 id="2-自定义一个中间件"><a href="#2-自定义一个中间件" class="headerlink" title="2. 自定义一个中间件"></a>2. 自定义一个中间件</h4><p>调用<code>django.utils.cache</code>模块，过滤request的参数，可以根据自定义的条件批量设置缓存。这种方式对程序员来说最友好，不用改动已有的代码，设置效率比较高。但这样要对每个request都进行过滤，看是否符合设置缓存的条件，势必会增加响应时间的消耗。这种方式的缓存也是存在浏览器上的。</p>
<p>如果本地没有缓存的话，那没辙，老老实实向server请求吧。</p>
<h3 id="服务器端缓存设置方式"><a href="#服务器端缓存设置方式" class="headerlink" title="服务器端缓存设置方式"></a>服务器端缓存设置方式</h3><p>使用Django的<code>django.views.decorators.cache</code>模块，在定义URL映射关系或者定义视图函数时，使用<code>@cache_control</code>或者<code>@cache_page</code>装饰器。这种方式粒度较小，可以控制的比较精细，但设置起来也比较繁琐。如此设置的缓存，是保留在Django配置的缓存后端里的。<br>Django通过配置Memcached（具体的配置方法请参阅文末附的Django文档），可以将某个URL的整个HTML文档存到Memcached中，这样下次有这个URL的请求时，就从Memcached中直接响应给request，请求不用server处理。这样的好处显而易见，一来可以提高响应速度，二来可以减轻server端的压力。一举两得，看起来简直完美，但是有没有弊端呢？这个世界是守恒的，上帝给你打开一扇窗的同时必然要从其他地方找补点回来。这种做法的弊端就是，存在Memcached中的HTML文档，如果有动态数据的话，在过期时间内它不会更新。所以，如果打算采用这种方法设置缓存，对于数据过期问题需要进行详细的考量。</p>
<p>这里只是记录下学习Django使用缓存的一些总结，没有涉及到具体的代码和配置项，如有需求，请查阅参考中附的文档及博客。</p>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ol>
<li>Django文档——<a href="https://docs.djangoproject.com/en/1.9/topics/cache/" target="_blank" rel="external">Django’s cache framework</a> </li>
<li><a href="http://www.zhangxinxu.com/wordpress/2013/05/caching-tutorial-for-web-authors-and-webmasters/" target="_blank" rel="external">翻译：web制作、开发人员需知的Web缓存知识</a> </li>
<li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn" target="_blank" rel="external">HTTP 缓存</a> </li>
<li><a href="http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/" target="_blank" rel="external">【Web缓存机制系列】2 – Web浏览器的缓存机制</a> </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ock7ps6a9.bkt.clouddn.com/image/blog/web_cache.png&quot; alt=&quot;web_cache&quot;&gt;&lt;/p&gt;
&lt;p&gt;给Web应用设置缓存好处多多，可以提高访问速度，改善用户体验，减轻服务器压力等。本篇主要整理一下前段时间设置服务器端和浏览器端缓存的方法，以及几种做法的优点与弊端。虽然只是来自Django的经验，但我相信对于其他编程语言和框架，原理上应该是一样的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Web" scheme="https://caitianxiong.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>学习双拼自然码</title>
    <link href="https://caitianxiong.github.io/2016/10/06/%E5%AD%A6%E4%B9%A0%E5%8F%8C%E6%8B%BC%E8%87%AA%E7%84%B6%E7%A0%81/"/>
    <id>https://caitianxiong.github.io/2016/10/06/学习双拼自然码/</id>
    <published>2016-10-06T03:10:30.000Z</published>
    <updated>2016-11-06T07:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ock7ps6a9.bkt.clouddn.com/image/blog/%E5%8F%8C%E6%8B%BC%E8%87%AA%E7%84%B6%E7%A0%81%E5%B8%83%E5%B1%80.jpg" alt="布局图"></p>
<h3 id="0-布局图"><a href="#0-布局图" class="headerlink" title="0. 布局图"></a>0. 布局图</h3><p>话说Leon吃完面，决定学习双拼自然码。于是盯着自然码布局图看。看了一会，恍然大悟：啊，我知道了！<br><a id="more"></a></p>
<h3 id="1-基本规则"><a href="#1-基本规则" class="headerlink" title="1. 基本规则"></a>1. 基本规则</h3><p>双拼的第一个字母表示汉字的声母（键位上蓝色的字母），第二个字母表示汉字的韵母（键位上红色的字母串）。</p>
<h3 id="2-蓝色部分"><a href="#2-蓝色部分" class="headerlink" title="2. 蓝色部分"></a>2. 蓝色部分</h3><p>6个韵母：aoeiuv自身没法当声母，所以AO键没有蓝色编码，E的蓝色编码是单引号’，IUV的蓝色编码分别是ch/sh/zh。于是乎，ii是吃，uu是书，vv是追。其他的字母，自己就可以当声母，所以蓝色的编码就是本身。</p>
<h3 id="3-红色部分"><a href="#3-红色部分" class="headerlink" title="3. 红色部分"></a>3. 红色部分</h3><p>汉语拼音的韵母很多，我打算按字母个数进行分类：</p>
<h5 id="1个字母"><a href="#1个字母" class="headerlink" title="1个字母"></a>1个字母</h5><ul>
<li>aoeiuv，分别在AOEIUV键位上。这样aa是啊，oo是哦，ee是额</li>
</ul>
<h5 id="2个字母"><a href="#2个字母" class="headerlink" title="2个字母"></a>2个字母</h5><ul>
<li>ai/ao/an，分别位于LKJ三个相邻的键上，这样ll是来，kk是靠</li>
<li>ou，在B上</li>
<li>ei/en/er，在Z/F/R上，这样zz是贼，ff是分</li>
<li>iu/ia/ie/in，分别在Q/W/X/N上，于是qq是邱，xx是写，nn是您</li>
<li>ua/ue/uo/un/ui，分别在W/T/O/P/V上，于是这几个声母和韵母都搭不上，连敲两下没办法拼成一个汉字</li>
</ul>
<h5 id="3个字母"><a href="#3个字母" class="headerlink" title="3个字母"></a>3个字母</h5><ul>
<li>ang，在H上，所以hh是航</li>
<li>ong，在S上，所以ss是送</li>
<li>eng，在G上，所以gg是更</li>
<li>ing/iao/ian，在Y/C/M上，这样yy打出来的是赢，cc是次奥（误），mm是面～</li>
<li>uan/uai，在R/Y上，这样rr是软…</li>
</ul>
<h5 id="4个字母"><a href="#4个字母" class="headerlink" title="4个字母"></a>4个字母</h5><ul>
<li>iong/iang/uang，在S/D上，比如打“雄”字，只需要敲xs就可以了，可以少敲3个字母</li>
</ul>
<h3 id="4-设计规律"><a href="#4-设计规律" class="headerlink" title="4. 设计规律"></a>4. 设计规律</h3><ul>
<li>将韵母放到发音相近的键位上，如er放在R上，in放在N上，uo放在o上</li>
<li>将相关的放到相邻，如F/G上分别是en/eng，J/H上分别是an/ang</li>
<li>位置对称，如ua在W键，uo在O键，指法正确的话，分别在左右手的无名指位置</li>
<li>其他的，找不出什么规律了，靠熟能生巧吧</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ock7ps6a9.bkt.clouddn.com/image/blog/%E5%8F%8C%E6%8B%BC%E8%87%AA%E7%84%B6%E7%A0%81%E5%B8%83%E5%B1%80.jpg&quot; alt=&quot;布局图&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;0-布局图&quot;&gt;&lt;a href=&quot;#0-布局图&quot; class=&quot;headerlink&quot; title=&quot;0. 布局图&quot;&gt;&lt;/a&gt;0. 布局图&lt;/h3&gt;&lt;p&gt;话说Leon吃完面，决定学习双拼自然码。于是盯着自然码布局图看。看了一会，恍然大悟：啊，我知道了！&lt;br&gt;
    
    </summary>
    
    
      <category term="学习" scheme="https://caitianxiong.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Openstack控制台项目Horizon后台代码结构分析</title>
    <link href="https://caitianxiong.github.io/2016/09/21/intro-to-openstack-dashboard/"/>
    <id>https://caitianxiong.github.io/2016/09/21/intro-to-openstack-dashboard/</id>
    <published>2016-09-21T13:02:29.000Z</published>
    <updated>2017-02-28T06:30:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ock7ps6a9.bkt.clouddn.com/image/blog/openstack-architecture.jpg" alt="openstack-components"></p>
<h2 id="1-Horizon项目在Openstack中的位置"><a href="#1-Horizon项目在Openstack中的位置" class="headerlink" title="1. Horizon项目在Openstack中的位置"></a>1. Horizon项目在Openstack中的位置</h2><p>控制台是用户使用Openstack服务的入口，Openstack的所有服务都通过控制台呈现给用户。Horizon和所有其他组件都有交互，通过Keystone认证后，以调用其他组件api的形式来进行使用。<br><a id="more"></a></p>
<h2 id="2-Horizon代码架构"><a href="#2-Horizon代码架构" class="headerlink" title="2. Horizon代码架构"></a>2. Horizon代码架构</h2><p>Horizon项目核心的代码包有两个：<code>openstack-dashboard</code>和<code>python-django-horizon</code>。</p>
<p>第一个包是控制台代码的具体实现，是一个基于Django框架的web应用，安装后主要文件在<code>/usr/share/openstack-dashboard/</code>路径下。第二个包是通用的一些Python类库，也包括一些静态文件，安装后在<code>/usr/lib/python2.7/dist-packages/horizon</code>下。定制化开发，主要是修改业务代码，基本不需要修改<code>python-django-horizon</code>，所以我们分析的重点放在<code>openstack-dashboard</code>这个包上。</p>
<h3 id="2-1-控制台组件名词说明"><a href="#2-1-控制台组件名词说明" class="headerlink" title="2.1 控制台组件名词说明"></a>2.1 控制台组件名词说明</h3><p><img src="http://ock7ps6a9.bkt.clouddn.com/image/blog/OpenStack_%20Dashboard.png" alt="openstack-dashboard"></p>
<p>图中的7个名词在代码中都可以对应上，代码的层级结构还是很清晰的。</p>
<h3 id="2-1-基于Django，MTV模式"><a href="#2-1-基于Django，MTV模式" class="headerlink" title="2.1 基于Django，MTV模式"></a>2.1 基于Django，MTV模式</h3><p><img src="http://ock7ps6a9.bkt.clouddn.com/image/blog/Django-workflow.png" alt="Django-workflow"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/usr/share/openstack-dashboard/</div><div class="line">|-- bin                             # </div><div class="line">|-- manage.py                       # 一些django命令</div><div class="line">|-- openstack_dashboard             # 控制台项目代码</div><div class="line">|-- settings.py                     # Django项目配置文件</div><div class="line">└-- static                          # 压缩后的静态文件</div></pre></td></tr></table></figure>
<p>从最外层目录看，这是一个典型的Django项目。再进去一层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/usr/share/openstack-dashboard/openstack_dashboard</div><div class="line">|-- __init__.py</div><div class="line">|-- urls.py</div><div class="line">|-- views.py</div><div class="line">|-- settings.py</div><div class="line">|-- api                                # 调用其他服务api接口的代码文件</div><div class="line">|-- conf</div><div class="line">|-- contrib</div><div class="line">|-- dashboards                         # 控制台的每个panel_group和panel</div><div class="line">|-- enabled                            # 定义panel是否显示及显示顺序</div><div class="line">|-- local</div><div class="line">|-- locale                             # 语言包所在</div><div class="line">|-- management</div><div class="line">|--...</div><div class="line">|-- static                             # 压缩前的静态文件</div><div class="line">|-- static_settings.py</div><div class="line">|-- templates                          # 基础模板文件</div><div class="line">|-- templatetags</div><div class="line">|-- themes                             # 主题包所在</div><div class="line">|-- usage                              # 关于项目用量的代码</div><div class="line">|-- utils</div><div class="line">└-- wsgi</div></pre></td></tr></table></figure></p>
<p>沿着业务代码<code>dashboards</code>一路往里分析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dashboards/</div><div class="line">|-- __init__.py</div><div class="line">|-- admin         # 管理员</div><div class="line">|-- identity      # 身份管理</div><div class="line">|-- project       # 项目</div><div class="line">└-- settings      # 用户设置</div></pre></td></tr></table></figure>
<p>4个包相当于4个Django App，分别对应控制台左侧导航栏的3个dashboard和右上角的设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dashboards/project/</div><div class="line">|-- __init__.py</div><div class="line">|-- dashboard.py</div><div class="line">|-- models.py</div><div class="line">|-- access_and_security</div><div class="line">|-- containers</div><div class="line">|--...</div><div class="line">|-- stacks</div><div class="line">|-- static</div><div class="line">|-- volumes</div><div class="line">└-- vpn</div></pre></td></tr></table></figure>
<p><code>dashboards/project/</code>这个路径下，每一个包对应控制台导航栏的一个panel。拿其中的<code>access_and_security</code>为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dashboards/project/access_and_security/</div><div class="line">|-- __init__.py           # python包标记文件</div><div class="line">|-- panel.py              # 定义这个panel的基本参数</div><div class="line">|-- tabs.py               # 定义页面上的tab</div><div class="line">|-- urls.py               # 定义URL绑定</div><div class="line">|-- views.py              # 定义这个panel index页面的视图</div><div class="line">|-- api_access            # 访问API</div><div class="line">|-- floating_ips          # 浮动IP</div><div class="line">|-- keypairs              # 密钥对</div><div class="line">|-- security_groups       # 安全组</div><div class="line">|-- templates             # HTML模板文件</div><div class="line">└-- tests.py              # 测试代码</div></pre></td></tr></table></figure>
<p>其中，<code>templates</code>路径下是页面模块的模板文件，其他四个文件夹分别对应页面上的四个tab：安全组、密钥对、浮动IP、访问API。详细看下<code>floating_ips</code>下的代码文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">floating_ips/</div><div class="line">|-- __init__.py         # python包标记</div><div class="line">|-- urls.py             # 定义该页面的URL</div><div class="line">|-- views.py            # 定义视图函数</div><div class="line">|-- tables.py           # 定义表格及表格上的操作</div><div class="line">|-- forms.py            # 定义弹出窗的内容</div><div class="line">|-- workflows.py        # 定义一些操作的具体工作流</div><div class="line">└-- tests.py            # 测试代码</div></pre></td></tr></table></figure>
<p>具体的调用关系，页面上找个操作，根据URL，从<code>urls.py</code>开始，随着代码一路跟过去，就可以梳理出来。</p>
<h3 id="2-2-Pluggable可插拔式Panel"><a href="#2-2-Pluggable可插拔式Panel" class="headerlink" title="2.2 Pluggable可插拔式Panel"></a>2.2 Pluggable可插拔式Panel</h3><p>模块注册机制，<code>panel</code>注册到<code>dashboard</code>下，<code>dashboard</code>注册到<code>horizon</code>下，主要分这三层结构。<code>panel</code>的可插拔模式，靠配置文件中的定义，运行服务时动态加载<code>enabled/</code>下的文件来实现。要添加一个<code>panel</code>，只需要在响应的路径下添加代码包，然后按照<code>enabled/</code>已有文件的格式添加文件注册。要隐藏一个<code>panel</code>，可以删除<code>enabled/</code>路径下对应的py文件，或者在文件中加上<code>REMOVE_PANEL = True</code>。添加<code>dashboard</code>或者<code>panel_group</code>做法类似。</p>
<h2 id="3-定制开发"><a href="#3-定制开发" class="headerlink" title="3. 定制开发"></a>3. 定制开发</h2><p>光看不练假把式，参考<a href="http://docs.openstack.org/developer/horizon/tutorials/dashboard.html" target="_blank" rel="external">这个教程</a>  ，可以添加一个简单的<code>dashboard</code>来练手。这个<code>dashboard</code>下有一个<code>panel_group</code>，<code>panel_group</code>下只有一个panel。页面上有一个tab，内容是一个简单的表格，表格上带一些简单的操作。</p>
<p>官网的<a href="http://docs.openstack.org/developer/horizon/tutorials/table_actions.html" target="_blank" rel="external">这篇教程</a>，可以做出复杂一点的表格操作。如果要开发自己的JS工作流，可以参考<a href="http://docs.openstack.org/developer/horizon/tutorials/workflow_extend.html" target="_blank" rel="external">这篇</a> 。</p>
<p>对于修改已有代码的开发，需要注意进行充分的测试，确保修改的内容没有对其他模块产生影响。</p>
<p><strong>参考</strong></p>
<ol>
<li><p><a href="http://docs.openstack.org/developer/horizon/" target="_blank" rel="external">官方文档 Horizon: The OpenStack Dashboard Project</a></p>
</li>
<li><p><a href="http://longliqiang88.github.io/2015/11/22/OpenStack%E4%B9%8BHorizon%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="external">OpenStack之Horizon源码分析</a></p>
</li>
<li><p><a href="http://blog.csdn.net/u011521019/article/details/44525451" target="_blank" rel="external">Horizon 源码阅读（二）—— Horizon 模块注册机制</a> </p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ock7ps6a9.bkt.clouddn.com/image/blog/openstack-architecture.jpg&quot; alt=&quot;openstack-components&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-Horizon项目在Openstack中的位置&quot;&gt;&lt;a href=&quot;#1-Horizon项目在Openstack中的位置&quot; class=&quot;headerlink&quot; title=&quot;1. Horizon项目在Openstack中的位置&quot;&gt;&lt;/a&gt;1. Horizon项目在Openstack中的位置&lt;/h2&gt;&lt;p&gt;控制台是用户使用Openstack服务的入口，Openstack的所有服务都通过控制台呈现给用户。Horizon和所有其他组件都有交互，通过Keystone认证后，以调用其他组件api的形式来进行使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="OpenStack" scheme="https://caitianxiong.github.io/tags/OpenStack/"/>
    
  </entry>
  
  <entry>
    <title>Xenserver 7.0安装Ceph-10.2.2</title>
    <link href="https://caitianxiong.github.io/2016/09/10/install-ceph-on-xenserver/"/>
    <id>https://caitianxiong.github.io/2016/09/10/install-ceph-on-xenserver/</id>
    <published>2016-09-10T12:51:37.000Z</published>
    <updated>2017-02-28T06:29:41.000Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>配置好yum源，更新完ceph-deploy，直接用ceph-deploy安装会报平台不支持的错，找到检测平台的相关代码，添加一项：【荣耀归于Eden大师】</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">distributions = &#123;</div><div class="line">        &apos;debian&apos;: debian,</div><div class="line">        &apos;ubuntu&apos;: debian,</div><div class="line">        &apos;centos&apos;: centos,</div><div class="line">        &apos;scientific&apos;: centos,</div><div class="line">        &apos;redhat&apos;: centos,</div><div class="line">        &apos;fedora&apos;: fedora,</div><div class="line">        &apos;suse&apos;: suse,</div><div class="line">        &apos;xenserver&apos;: centos,  # 添加的项</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>然后改yum源，用<code>yum install ceph  ceph-radosgw rdate -y</code>安装ceph主程序。</p>
</li>
<li><p>装完用ceph-deploy分配mon/osd节点。</p>
</li>
<li><p>如果遇到OSD进程起不来的问题，查看使用路径的FS，只支持ext4和xfs。若要使用ext3，在ceph.conf文件中添加以下两行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">osd max object name len = 256  # ext4或xfs使用2048</div><div class="line">osd max object namespace len = 256</div></pre></td></tr></table></figure>
</li>
<li><p>tricks</p>
</li>
</ol>
<ul>
<li>ubuntu 上用<code>stop ceph-osd id=X</code>来停OSD</li>
<li>搭单节点的集群，MON/OSD都装在一个host上，然后将pool size改成1，集群状态就可以HEALTH_OK了。</li>
<li>搭好集群后快速验证是否可用的方法：直接使用<code>rados -p rbd put {$NAME} {$FILE_PATH}</code>存一个文件，然后用<code>rados -p rbd put {$NAME} {$DIST_PATH}</code>取出</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;配置好yum源，更新完ceph-deploy，直接用ceph-deploy安装会报平台不支持的错，找到检测平台的相关代码，添加一项：【荣耀归于Eden大师】&lt;/p&gt;
    
    </summary>
    
    
      <category term="Ceph" scheme="https://caitianxiong.github.io/tags/Ceph/"/>
    
  </entry>
  
  <entry>
    <title>学习C语言调试工具gdb</title>
    <link href="https://caitianxiong.github.io/2016/09/03/learn-gdb/"/>
    <id>https://caitianxiong.github.io/2016/09/03/learn-gdb/</id>
    <published>2016-09-03T00:21:56.000Z</published>
    <updated>2016-11-06T11:21:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ock7ps6a9.bkt.clouddn.com/image/blog/gdb-logo.png" alt="gdb-logo"><br>最近在学C语，用的是《<a href="http://baike.baidu.com/link?url=mpMUMWU_KP3iuJvVDNRN2fJpddcPO87WcXAml61ManrvFZOJtKaiuqilEnZrDklonnhUWlgScBoAsTwMjWzscMIMpIzG7bYwaRvkTiQUpLwzWW47jLXOzDgGrtY8cguglkE-HfIDt2BzkzaMGDkJPHbQXLvjs79g7ajIcSWvDH5HTXEy2UKfKTwuU9islSgi" target="_blank" rel="external">C语言程序设计（第4版）</a>》。看到倒数第二章讲调试程序，我才第一次接触到gdb。想到python也有个调试工具叫pdb，估计也是从gdb演化过来的。打算去好好研究下pdb，不然调试web项目的时候总是用print/log的方式，一来效率低，二来很low。<br><a id="more"></a></p>
<p>gdb是GNU项目的调试工具，可以用来调试C/C++/Objective-C等。gdb的官方介绍：</p>
<blockquote>
<p>What is GDB?<br>GDB, the GNU Project debugger, allows you to see what is going on `inside’ another program while it executes – or what another program was doing at the moment it crashed.<br>GDB can do four main kinds of things (plus other things in support of these) to help you catch bugs in the act:<br>Start your program, specifying anything that might affect its behavior.<br>Make your program stop on specified conditions.<br>Examine what has happened, when your program has stopped.<br>Change things in your program, so you can experiment with correcting the effects of one bug and go on to learn about another.<br>The program being debugged can be written in Ada, C, C++, Objective-C, Pascal (and many other languages). Those programs might be executing on the same machine as GDB (native) or on another machine (remote). GDB can run on most popular UNIX and Microsoft Windows variants.</p>
</blockquote>
<p>在终端输入<code>gdb --version</code>可以查看gdb的版本号，如果你的系统上没有的话，直接用系统自带的包管理工具应该就可以安装。我用的是Ubuntu 16.04上安装的7.11.1版本。</p>
<p>使用gdb调试C程序的一般流程：</p>
<ul>
<li>gcc编译C源文件时加-g参数生成调试信息</li>
<li>gdb a.out开始调试</li>
<li>用list加函数名查看要调试的函数</li>
<li>用break加函数名或者行号添加断点</li>
<li>info break列出所有断点</li>
<li>clear加行号清除那行的断点，或者clear加函数名清除函数入口处的断点</li>
<li>run，把程序跑起来，到运行到断点处会自动暂停</li>
<li>print加变量名查看此时的变量值</li>
<li>step加行号步进执行</li>
<li>info locals查看所有局部变量的值</li>
<li>watch加变量名来监视变量，一旦变量值发生变化或满足设定的条件，就会暂停执行。例如，设置<code>watch i if i &lt; 0</code>，会在<code>i&lt;0</code>时停住，等待调试。</li>
<li>continue继续执行</li>
<li>quit退出调试</li>
</ul>
<p>一些技巧：</p>
<ul>
<li>help命令获取帮助，会列出所有可用类。help [<em>cmd/class</em>]，查看具体的命令或者类的帮助信息。</li>
<li>可以采用<code>函数::变量</code>的形式将函数作为变量的一部分，用于引用一个特定例程的局部变量。比如：<br><code>(gdb) print main::i</code>    显示main中i的值<br><code>(gdb) set var main::i=0</code>   为main中的i赋值<br>需要注意的是，这种方式只能给活动的函数赋值，如果是对非活动的函数，会报错。<br>类似的，可以用<code>&#39;file&#39;::var</code>的形式引用某个文件的全局变量。</li>
<li>gdb在达到一个断点后，或者在一次单步执行后，列出的是将要执行的代码行，而不是刚执行过的。</li>
<li>可以用命令bt(backtrack)查看函数的调用栈。</li>
</ul>
<blockquote>
<p>…you can’t be a great programmer until you become highly skilled at Debugging.<br>——《The Pragmatic Programmer》</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ock7ps6a9.bkt.clouddn.com/image/blog/gdb-logo.png&quot; alt=&quot;gdb-logo&quot;&gt;&lt;br&gt;最近在学C语，用的是《&lt;a href=&quot;http://baike.baidu.com/link?url=mpMUMWU_KP3iuJvVDNRN2fJpddcPO87WcXAml61ManrvFZOJtKaiuqilEnZrDklonnhUWlgScBoAsTwMjWzscMIMpIzG7bYwaRvkTiQUpLwzWW47jLXOzDgGrtY8cguglkE-HfIDt2BzkzaMGDkJPHbQXLvjs79g7ajIcSWvDH5HTXEy2UKfKTwuU9islSgi&quot;&gt;C语言程序设计（第4版）&lt;/a&gt;》。看到倒数第二章讲调试程序，我才第一次接触到gdb。想到python也有个调试工具叫pdb，估计也是从gdb演化过来的。打算去好好研究下pdb，不然调试web项目的时候总是用print/log的方式，一来效率低，二来很low。&lt;br&gt;
    
    </summary>
    
    
      <category term="C语" scheme="https://caitianxiong.github.io/tags/C%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>关于这个博客</title>
    <link href="https://caitianxiong.github.io/2016/08/28/My-Own-Blog/"/>
    <id>https://caitianxiong.github.io/2016/08/28/My-Own-Blog/</id>
    <published>2016-08-28T05:01:50.000Z</published>
    <updated>2017-02-28T07:59:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ock7ps6a9.bkt.clouddn.com/image/blog/have_a_nice_day.jpg" alt="Have A Nice Day"><br><a id="more"></a><br>距离上次发博客文章，已经有一年多了，当时是在CSDN上记录学习Flask的过程。后来忙于工作（懒），就只是草草记在自己的笔记软件上。</p>
<p>一直想搭建自己的博客，这样能促使我认真写一些东西分享出来，毕竟，对于属于自己的东西，会多一份责任感。拖了好久，正好这周Crossin先生的公众号上发了两篇教程，于是决定利用这个周末搭一套出来。于是有了这个博客。</p>
<p>以后会好好维护，记录下自己的学习过程，总结一些对别人有用的东西分享出来。<br>涉及的主题包括（但不限于）：</p>
<ul>
<li>Python</li>
<li>Linux</li>
<li>Openstack</li>
<li>Ceph</li>
</ul>
<p>另外，这个博客的名字和头像，都是来自我喜欢的摇滚歌手Bon Jovi的同名专辑。</p>
<center><br><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=16850569&auto=0&height=66"><br></iframe><br></center>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ock7ps6a9.bkt.clouddn.com/image/blog/have_a_nice_day.jpg&quot; alt=&quot;Have A Nice Day&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Blog" scheme="https://caitianxiong.github.io/tags/Blog/"/>
    
  </entry>
  
</feed>
